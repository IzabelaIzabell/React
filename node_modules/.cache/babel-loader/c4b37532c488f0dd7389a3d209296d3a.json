{"ast":null,"code":"/*\n Highcharts JS v7.1.1 (2019-04-09)\n\n Highmaps as a plugin for Highcharts or Highstock.\n\n (c) 2011-2019 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (g) {\n  \"object\" === typeof module && module.exports ? (g[\"default\"] = g, module.exports = g) : \"function\" === typeof define && define.amd ? define(\"highcharts/modules/map\", [\"highcharts\"], function (z) {\n    g(z);\n    g.Highcharts = z;\n    return g;\n  }) : g(\"undefined\" !== typeof Highcharts ? Highcharts : void 0);\n})(function (g) {\n  function z(a, g, h, t) {\n    a.hasOwnProperty(g) || (a[g] = t.apply(null, h));\n  }\n\n  g = g ? g._modules : {};\n  z(g, \"parts-map/MapAxis.js\", [g[\"parts/Globals.js\"]], function (a) {\n    var g = a.addEvent,\n        h = a.Axis,\n        t = a.pick;\n    g(h, \"getSeriesExtremes\", function () {\n      var a = [];\n      this.isXAxis && (this.series.forEach(function (d, r) {\n        d.useMapGeometry && (a[r] = d.xData, d.xData = []);\n      }), this.seriesXData = a);\n    });\n    g(h, \"afterGetSeriesExtremes\", function () {\n      var a = this.seriesXData,\n          d,\n          q,\n          h;\n      this.isXAxis && (d = t(this.dataMin, Number.MAX_VALUE), q = t(this.dataMax, -Number.MAX_VALUE), this.series.forEach(function (e, b) {\n        e.useMapGeometry && (d = Math.min(d, t(e.minX, d)), q = Math.max(q, t(e.maxX, q)), e.xData = a[b], h = !0);\n      }), h && (this.dataMin = d, this.dataMax = q), delete this.seriesXData);\n    });\n    g(h, \"afterSetAxisTranslation\", function () {\n      var a = this.chart,\n          d;\n      d = a.plotWidth / a.plotHeight;\n      var a = a.xAxis[0],\n          h;\n      \"yAxis\" === this.coll && void 0 !== a.transA && this.series.forEach(function (a) {\n        a.preserveAspectRatio && (h = !0);\n      });\n\n      if (h && (this.transA = a.transA = Math.min(this.transA, a.transA), d /= (a.max - a.min) / (this.max - this.min), d = 1 > d ? this : a, a = (d.max - d.min) * d.transA, d.pixelPadding = d.len - a, d.minPixelPadding = d.pixelPadding / 2, a = d.fixTo)) {\n        a = a[1] - d.toValue(a[0], !0);\n        a *= d.transA;\n        if (Math.abs(a) > d.minPixelPadding || d.min === d.dataMin && d.max === d.dataMax) a = 0;\n        d.minPixelPadding -= a;\n      }\n    });\n    g(h, \"render\", function () {\n      this.fixTo = null;\n    });\n  });\n  z(g, \"parts-map/ColorAxis.js\", [g[\"parts/Globals.js\"]], function (a) {\n    var g = a.addEvent,\n        h = a.Axis,\n        t = a.Chart,\n        r = a.color,\n        d,\n        q = a.extend,\n        x = a.isNumber,\n        e = a.Legend,\n        b = a.LegendSymbolMixin,\n        f = a.noop,\n        y = a.merge,\n        p = a.pick;\n\n    d = a.ColorAxis = function () {\n      this.init.apply(this, arguments);\n    };\n\n    q(d.prototype, h.prototype);\n    q(d.prototype, {\n      defaultColorAxisOptions: {\n        lineWidth: 0,\n        minPadding: 0,\n        maxPadding: 0,\n        gridLineWidth: 1,\n        tickPixelInterval: 72,\n        startOnTick: !0,\n        endOnTick: !0,\n        offset: 0,\n        marker: {\n          animation: {\n            duration: 50\n          },\n          width: .01,\n          color: \"#999999\"\n        },\n        labels: {\n          overflow: \"justify\",\n          rotation: 0\n        },\n        minColor: \"#e6ebf5\",\n        maxColor: \"#003399\",\n        tickLength: 5,\n        showInLegend: !0\n      },\n      keepProps: [\"legendGroup\", \"legendItemHeight\", \"legendItemWidth\", \"legendItem\", \"legendSymbol\"].concat(h.prototype.keepProps),\n      init: function init(c, m) {\n        var k = \"vertical\" !== c.options.legend.layout,\n            a;\n        this.coll = \"colorAxis\";\n        a = y(this.defaultColorAxisOptions, {\n          side: k ? 2 : 1,\n          reversed: !k\n        }, m, {\n          opposite: !k,\n          showEmpty: !1,\n          title: null,\n          visible: c.options.legend.enabled\n        });\n        h.prototype.init.call(this, c, a);\n        m.dataClasses && this.initDataClasses(m);\n        this.initStops();\n        this.horiz = k;\n        this.zoomEnabled = !1;\n        this.defaultLegendLength = 200;\n      },\n      initDataClasses: function initDataClasses(c) {\n        var m = this.chart,\n            k,\n            a = 0,\n            l = m.options.chart.colorCount,\n            n = this.options,\n            b = c.dataClasses.length;\n        this.dataClasses = k = [];\n        this.legendItems = [];\n        c.dataClasses.forEach(function (c, w) {\n          c = y(c);\n          k.push(c);\n          if (m.styledMode || !c.color) \"category\" === n.dataClassColor ? (m.styledMode || (w = m.options.colors, l = w.length, c.color = w[a]), c.colorIndex = a, a++, a === l && (a = 0)) : c.color = r(n.minColor).tweenTo(r(n.maxColor), 2 > b ? .5 : w / (b - 1));\n        });\n      },\n      hasData: function hasData() {\n        return !(!this.tickPositions || !this.tickPositions.length);\n      },\n      setTickPositions: function setTickPositions() {\n        if (!this.dataClasses) return h.prototype.setTickPositions.call(this);\n      },\n      initStops: function initStops() {\n        this.stops = this.options.stops || [[0, this.options.minColor], [1, this.options.maxColor]];\n        this.stops.forEach(function (c) {\n          c.color = r(c[1]);\n        });\n      },\n      setOptions: function setOptions(c) {\n        h.prototype.setOptions.call(this, c);\n        this.options.crosshair = this.options.marker;\n      },\n      setAxisSize: function setAxisSize() {\n        var c = this.legendSymbol,\n            m = this.chart,\n            a = m.options.legend || {},\n            b,\n            l;\n        c ? (this.left = a = c.attr(\"x\"), this.top = b = c.attr(\"y\"), this.width = l = c.attr(\"width\"), this.height = c = c.attr(\"height\"), this.right = m.chartWidth - a - l, this.bottom = m.chartHeight - b - c, this.len = this.horiz ? l : c, this.pos = this.horiz ? a : b) : this.len = (this.horiz ? a.symbolWidth : a.symbolHeight) || this.defaultLegendLength;\n      },\n      normalizedValue: function normalizedValue(c) {\n        this.isLog && (c = this.val2lin(c));\n        return 1 - (this.max - c) / (this.max - this.min || 1);\n      },\n      toColor: function toColor(c, m) {\n        var a = this.stops,\n            b,\n            l,\n            n = this.dataClasses,\n            w,\n            f;\n        if (n) for (f = n.length; f--;) {\n          if (w = n[f], b = w.from, a = w.to, (void 0 === b || c >= b) && (void 0 === a || c <= a)) {\n            l = w.color;\n            m && (m.dataClass = f, m.colorIndex = w.colorIndex);\n            break;\n          }\n        } else {\n          c = this.normalizedValue(c);\n\n          for (f = a.length; f-- && !(c > a[f][0]);) {\n            ;\n          }\n\n          b = a[f] || a[f + 1];\n          a = a[f + 1] || b;\n          c = 1 - (a[0] - c) / (a[0] - b[0] || 1);\n          l = b.color.tweenTo(a.color, c);\n        }\n        return l;\n      },\n      getOffset: function getOffset() {\n        var c = this.legendGroup,\n            a = this.chart.axisOffset[this.side];\n        c && (this.axisParent = c, h.prototype.getOffset.call(this), this.added || (this.added = !0, this.labelLeft = 0, this.labelRight = this.width), this.chart.axisOffset[this.side] = a);\n      },\n      setLegendColor: function setLegendColor() {\n        var c,\n            a = this.reversed;\n        c = a ? 1 : 0;\n        a = a ? 0 : 1;\n        c = this.horiz ? [c, 0, a, 0] : [0, a, 0, c];\n        this.legendColor = {\n          linearGradient: {\n            x1: c[0],\n            y1: c[1],\n            x2: c[2],\n            y2: c[3]\n          },\n          stops: this.stops\n        };\n      },\n      drawLegendSymbol: function drawLegendSymbol(c, a) {\n        var m = c.padding,\n            b = c.options,\n            l = this.horiz,\n            n = p(b.symbolWidth, l ? this.defaultLegendLength : 12),\n            w = p(b.symbolHeight, l ? 12 : this.defaultLegendLength),\n            f = p(b.labelPadding, l ? 16 : 30),\n            b = p(b.itemDistance, 10);\n        this.setLegendColor();\n        a.legendSymbol = this.chart.renderer.rect(0, c.baseline - 11, n, w).attr({\n          zIndex: 1\n        }).add(a.legendGroup);\n        this.legendItemWidth = n + m + (l ? b : f);\n        this.legendItemHeight = w + m + (l ? f : 0);\n      },\n      setState: function setState(c) {\n        this.series.forEach(function (a) {\n          a.setState(c);\n        });\n      },\n      visible: !0,\n      setVisible: f,\n      getSeriesExtremes: function getSeriesExtremes() {\n        var c = this.series,\n            a = c.length;\n        this.dataMin = Infinity;\n\n        for (this.dataMax = -Infinity; a--;) {\n          c[a].getExtremes(), void 0 !== c[a].valueMin && (this.dataMin = Math.min(this.dataMin, c[a].valueMin), this.dataMax = Math.max(this.dataMax, c[a].valueMax));\n        }\n      },\n      drawCrosshair: function drawCrosshair(c, a) {\n        var b = a && a.plotX,\n            m = a && a.plotY,\n            l,\n            n = this.pos,\n            w = this.len;\n        a && (l = this.toPixels(a[a.series.colorKey]), l < n ? l = n - 2 : l > n + w && (l = n + w + 2), a.plotX = l, a.plotY = this.len - l, h.prototype.drawCrosshair.call(this, c, a), a.plotX = b, a.plotY = m, this.cross && !this.cross.addedToColorAxis && this.legendGroup && (this.cross.addClass(\"highcharts-coloraxis-marker\").add(this.legendGroup), this.cross.addedToColorAxis = !0, this.chart.styledMode || this.cross.attr({\n          fill: this.crosshair.color\n        })));\n      },\n      getPlotLinePath: function getPlotLinePath(c, a, b, f, l) {\n        return x(l) ? this.horiz ? [\"M\", l - 4, this.top - 6, \"L\", l + 4, this.top - 6, l, this.top, \"Z\"] : [\"M\", this.left, l, \"L\", this.left - 6, l + 6, this.left - 6, l - 6, \"Z\"] : h.prototype.getPlotLinePath.call(this, c, a, b, f);\n      },\n      update: function update(c, a) {\n        var b = this.chart,\n            m = b.legend;\n        this.series.forEach(function (c) {\n          c.isDirtyData = !0;\n        });\n        c.dataClasses && m.allItems && (m.allItems.forEach(function (c) {\n          c.isDataClass && c.legendGroup && c.legendGroup.destroy();\n        }), b.isDirtyLegend = !0);\n        b.options[this.coll] = y(this.userOptions, c);\n        h.prototype.update.call(this, c, a);\n        this.legendItem && (this.setLegendColor(), m.colorizeItem(this, !0));\n      },\n      remove: function remove() {\n        this.legendItem && this.chart.legend.destroyItem(this);\n        h.prototype.remove.call(this);\n      },\n      getDataClassLegendSymbols: function getDataClassLegendSymbols() {\n        var c = this,\n            m = this.chart,\n            k = this.legendItems,\n            e = m.options.legend,\n            l = e.valueDecimals,\n            n = e.valueSuffix || \"\",\n            w;\n        k.length || this.dataClasses.forEach(function (e, u) {\n          var A = !0,\n              d = e.from,\n              v = e.to;\n          w = \"\";\n          void 0 === d ? w = \"\\x3c \" : void 0 === v && (w = \"\\x3e \");\n          void 0 !== d && (w += a.numberFormat(d, l) + n);\n          void 0 !== d && void 0 !== v && (w += \" - \");\n          void 0 !== v && (w += a.numberFormat(v, l) + n);\n          k.push(q({\n            chart: m,\n            name: w,\n            options: {},\n            drawLegendSymbol: b.drawRectangle,\n            visible: !0,\n            setState: f,\n            isDataClass: !0,\n            setVisible: function setVisible() {\n              A = this.visible = !A;\n              c.series.forEach(function (c) {\n                c.points.forEach(function (c) {\n                  c.dataClass === u && c.setVisible(A);\n                });\n              });\n              m.legend.colorizeItem(this, A);\n            }\n          }, e));\n        });\n        return k;\n      },\n      name: \"\"\n    });\n    [\"fill\", \"stroke\"].forEach(function (c) {\n      a.Fx.prototype[c + \"Setter\"] = function () {\n        this.elem.attr(c, r(this.start).tweenTo(r(this.end), this.pos), null, !0);\n      };\n    });\n    g(t, \"afterGetAxes\", function () {\n      var c = this.options.colorAxis;\n      this.colorAxis = [];\n      c && new d(this, c);\n    });\n    g(e, \"afterGetAllItems\", function (c) {\n      var b = [],\n          k = this.chart.colorAxis[0];\n      k && k.options && k.options.showInLegend && (k.options.dataClasses ? b = k.getDataClassLegendSymbols() : b.push(k), k.series.forEach(function (b) {\n        a.erase(c.allItems, b);\n      }));\n\n      for (k = b.length; k--;) {\n        c.allItems.unshift(b[k]);\n      }\n    });\n    g(e, \"afterColorizeItem\", function (c) {\n      c.visible && c.item.legendColor && c.item.legendSymbol.attr({\n        fill: c.item.legendColor\n      });\n    });\n    g(e, \"afterUpdate\", function (c, a, b) {\n      this.chart.colorAxis[0] && this.chart.colorAxis[0].update({}, b);\n    });\n  });\n  z(g, \"parts-map/ColorSeriesMixin.js\", [g[\"parts/Globals.js\"]], function (a) {\n    var g = a.defined,\n        h = a.noop,\n        t = a.seriesTypes;\n    a.colorPointMixin = {\n      dataLabelOnNull: !0,\n      isValid: function isValid() {\n        return null !== this.value && Infinity !== this.value && -Infinity !== this.value;\n      },\n      setVisible: function setVisible(a) {\n        var d = this,\n            r = a ? \"show\" : \"hide\";\n        d.visible = !!a;\n        [\"graphic\", \"dataLabel\"].forEach(function (a) {\n          if (d[a]) d[a][r]();\n        });\n      },\n      setState: function setState(r) {\n        a.Point.prototype.setState.call(this, r);\n        this.graphic && this.graphic.attr({\n          zIndex: \"hover\" === r ? 1 : 0\n        });\n      }\n    };\n    a.colorSeriesMixin = {\n      pointArrayMap: [\"value\"],\n      axisTypes: [\"xAxis\", \"yAxis\", \"colorAxis\"],\n      optionalAxis: \"colorAxis\",\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      getSymbol: h,\n      parallelArrays: [\"x\", \"y\", \"value\"],\n      colorKey: \"value\",\n      pointAttribs: t.column.prototype.pointAttribs,\n      translateColors: function translateColors() {\n        var a = this,\n            d = this.options.nullColor,\n            h = this.colorAxis,\n            g = this.colorKey;\n        this.data.forEach(function (e) {\n          var b = e[g];\n          if (b = e.options.color || (e.isNull ? d : h && void 0 !== b ? h.toColor(b, e) : e.color || a.color)) e.color = b;\n        });\n      },\n      colorAttribs: function colorAttribs(a) {\n        var d = {};\n        g(a.color) && (d[this.colorProp || \"fill\"] = a.color);\n        return d;\n      }\n    };\n  });\n  z(g, \"parts-map/MapNavigation.js\", [g[\"parts/Globals.js\"]], function (a) {\n    function g(a) {\n      a && (a.preventDefault && a.preventDefault(), a.stopPropagation && a.stopPropagation(), a.cancelBubble = !0);\n    }\n\n    function h(a) {\n      this.init(a);\n    }\n\n    var t = a.addEvent,\n        r = a.Chart,\n        d = a.doc,\n        q = a.extend,\n        x = a.merge,\n        e = a.pick;\n\n    h.prototype.init = function (a) {\n      this.chart = a;\n      a.mapNavButtons = [];\n    };\n\n    h.prototype.update = function (b) {\n      var f = this.chart,\n          d = f.options.mapNavigation,\n          p,\n          c,\n          m,\n          k,\n          v,\n          l = function l(a) {\n        this.handler.call(f, a);\n        g(a);\n      },\n          n = f.mapNavButtons;\n\n      b && (d = f.options.mapNavigation = x(f.options.mapNavigation, b));\n\n      for (; n.length;) {\n        n.pop().destroy();\n      }\n\n      e(d.enableButtons, d.enabled) && !f.renderer.forExport && a.objectEach(d.buttons, function (a, b) {\n        p = x(d.buttonOptions, a);\n        f.styledMode || (c = p.theme, c.style = x(p.theme.style, p.style), k = (m = c.states) && m.hover, v = m && m.select);\n        a = f.renderer.button(p.text, 0, 0, l, c, k, v, 0, \"zoomIn\" === b ? \"topbutton\" : \"bottombutton\").addClass(\"highcharts-map-navigation highcharts-\" + {\n          zoomIn: \"zoom-in\",\n          zoomOut: \"zoom-out\"\n        }[b]).attr({\n          width: p.width,\n          height: p.height,\n          title: f.options.lang[b],\n          padding: p.padding,\n          zIndex: 5\n        }).add();\n        a.handler = p.onclick;\n        a.align(q(p, {\n          width: a.width,\n          height: 2 * a.height\n        }), null, p.alignTo);\n        t(a.element, \"dblclick\", g);\n        n.push(a);\n      });\n      this.updateEvents(d);\n    };\n\n    h.prototype.updateEvents = function (a) {\n      var b = this.chart;\n      e(a.enableDoubleClickZoom, a.enabled) || a.enableDoubleClickZoomTo ? this.unbindDblClick = this.unbindDblClick || t(b.container, \"dblclick\", function (a) {\n        b.pointer.onContainerDblClick(a);\n      }) : this.unbindDblClick && (this.unbindDblClick = this.unbindDblClick());\n      e(a.enableMouseWheelZoom, a.enabled) ? this.unbindMouseWheel = this.unbindMouseWheel || t(b.container, void 0 === d.onmousewheel ? \"DOMMouseScroll\" : \"mousewheel\", function (a) {\n        b.pointer.onContainerMouseWheel(a);\n        g(a);\n        return !1;\n      }) : this.unbindMouseWheel && (this.unbindMouseWheel = this.unbindMouseWheel());\n    };\n\n    q(r.prototype, {\n      fitToBox: function fitToBox(a, f) {\n        [[\"x\", \"width\"], [\"y\", \"height\"]].forEach(function (b) {\n          var e = b[0];\n          b = b[1];\n          a[e] + a[b] > f[e] + f[b] && (a[b] > f[b] ? (a[b] = f[b], a[e] = f[e]) : a[e] = f[e] + f[b] - a[b]);\n          a[b] > f[b] && (a[b] = f[b]);\n          a[e] < f[e] && (a[e] = f[e]);\n        });\n        return a;\n      },\n      mapZoom: function mapZoom(a, f, d, r, c) {\n        var b = this.xAxis[0],\n            k = b.max - b.min,\n            v = e(f, b.min + k / 2),\n            l = k * a,\n            k = this.yAxis[0],\n            n = k.max - k.min,\n            w = e(d, k.min + n / 2),\n            n = n * a,\n            v = this.fitToBox({\n          x: v - l * (r ? (r - b.pos) / b.len : .5),\n          y: w - n * (c ? (c - k.pos) / k.len : .5),\n          width: l,\n          height: n\n        }, {\n          x: b.dataMin,\n          y: k.dataMin,\n          width: b.dataMax - b.dataMin,\n          height: k.dataMax - k.dataMin\n        }),\n            l = v.x <= b.dataMin && v.width >= b.dataMax - b.dataMin && v.y <= k.dataMin && v.height >= k.dataMax - k.dataMin;\n        r && (b.fixTo = [r - b.pos, f]);\n        c && (k.fixTo = [c - k.pos, d]);\n        void 0 === a || l ? (b.setExtremes(void 0, void 0, !1), k.setExtremes(void 0, void 0, !1)) : (b.setExtremes(v.x, v.x + v.width, !1), k.setExtremes(v.y, v.y + v.height, !1));\n        this.redraw();\n      }\n    });\n    t(r, \"beforeRender\", function () {\n      this.mapNavigation = new h(this);\n      this.mapNavigation.update();\n    });\n    a.MapNavigation = h;\n  });\n  z(g, \"parts-map/MapPointer.js\", [g[\"parts/Globals.js\"]], function (a) {\n    var g = a.extend,\n        h = a.pick,\n        t = a.Pointer;\n    a = a.wrap;\n    g(t.prototype, {\n      onContainerDblClick: function onContainerDblClick(a) {\n        var d = this.chart;\n        a = this.normalize(a);\n        d.options.mapNavigation.enableDoubleClickZoomTo ? d.pointer.inClass(a.target, \"highcharts-tracker\") && d.hoverPoint && d.hoverPoint.zoomTo() : d.isInsidePlot(a.chartX - d.plotLeft, a.chartY - d.plotTop) && d.mapZoom(.5, d.xAxis[0].toValue(a.chartX), d.yAxis[0].toValue(a.chartY), a.chartX, a.chartY);\n      },\n      onContainerMouseWheel: function onContainerMouseWheel(a) {\n        var d = this.chart,\n            g;\n        a = this.normalize(a);\n        g = a.detail || -(a.wheelDelta / 120);\n        d.isInsidePlot(a.chartX - d.plotLeft, a.chartY - d.plotTop) && d.mapZoom(Math.pow(d.options.mapNavigation.mouseWheelSensitivity, g), d.xAxis[0].toValue(a.chartX), d.yAxis[0].toValue(a.chartY), a.chartX, a.chartY);\n      }\n    });\n    a(t.prototype, \"zoomOption\", function (a) {\n      var d = this.chart.options.mapNavigation;\n      h(d.enableTouchZoom, d.enabled) && (this.chart.options.chart.pinchType = \"xy\");\n      a.apply(this, [].slice.call(arguments, 1));\n    });\n    a(t.prototype, \"pinchTranslate\", function (a, d, g, h, e, b, f) {\n      a.call(this, d, g, h, e, b, f);\n      \"map\" === this.chart.options.chart.type && this.hasZoom && (a = h.scaleX > h.scaleY, this.pinchTranslateDirection(!a, d, g, h, e, b, f, a ? h.scaleX : h.scaleY));\n    });\n  });\n  z(g, \"parts-map/MapSeries.js\", [g[\"parts/Globals.js\"]], function (a) {\n    var g = a.colorPointMixin,\n        h = a.extend,\n        t = a.isNumber,\n        r = a.merge,\n        d = a.noop,\n        q = a.pick,\n        x = a.isArray,\n        e = a.Point,\n        b = a.Series,\n        f = a.seriesType,\n        y = a.seriesTypes,\n        p = a.splat;\n    f(\"map\", \"scatter\", {\n      animation: !1,\n      dataLabels: {\n        crop: !1,\n        formatter: function formatter() {\n          return this.point.value;\n        },\n        inside: !0,\n        overflow: !1,\n        padding: 0,\n        verticalAlign: \"middle\"\n      },\n      marker: null,\n      nullColor: \"#f7f7f7\",\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0,\n        pointFormat: \"{point.name}: {point.value}\\x3cbr/\\x3e\"\n      },\n      turboThreshold: 0,\n      allAreas: !0,\n      borderColor: \"#cccccc\",\n      borderWidth: 1,\n      joinBy: \"hc-key\",\n      states: {\n        hover: {\n          halo: null,\n          brightness: .2\n        },\n        normal: {\n          animation: !0\n        },\n        select: {\n          color: \"#cccccc\"\n        },\n        inactive: {\n          opacity: 1\n        }\n      }\n    }, r(a.colorSeriesMixin, {\n      type: \"map\",\n      getExtremesFromAll: !0,\n      useMapGeometry: !0,\n      forceDL: !0,\n      searchPoint: d,\n      directTouch: !0,\n      preserveAspectRatio: !0,\n      pointArrayMap: [\"value\"],\n      getBox: function getBox(c) {\n        var b = Number.MAX_VALUE,\n            k = -b,\n            f = b,\n            l = -b,\n            n = b,\n            w = b,\n            e = this.xAxis,\n            d = this.yAxis,\n            g;\n        (c || []).forEach(function (c) {\n          if (c.path) {\n            \"string\" === typeof c.path && (c.path = a.splitPath(c.path));\n            var m = c.path || [],\n                e = m.length,\n                d = !1,\n                u = -b,\n                A = b,\n                v = -b,\n                h = b,\n                p = c.properties;\n\n            if (!c._foundBox) {\n              for (; e--;) {\n                t(m[e]) && (d ? (u = Math.max(u, m[e]), A = Math.min(A, m[e])) : (v = Math.max(v, m[e]), h = Math.min(h, m[e])), d = !d);\n              }\n\n              c._midX = A + (u - A) * q(c.middleX, p && p[\"hc-middle-x\"], .5);\n              c._midY = h + (v - h) * q(c.middleY, p && p[\"hc-middle-y\"], .5);\n              c._maxX = u;\n              c._minX = A;\n              c._maxY = v;\n              c._minY = h;\n              c.labelrank = q(c.labelrank, (u - A) * (v - h));\n              c._foundBox = !0;\n            }\n\n            k = Math.max(k, c._maxX);\n            f = Math.min(f, c._minX);\n            l = Math.max(l, c._maxY);\n            n = Math.min(n, c._minY);\n            w = Math.min(c._maxX - c._minX, c._maxY - c._minY, w);\n            g = !0;\n          }\n        });\n        g && (this.minY = Math.min(n, q(this.minY, b)), this.maxY = Math.max(l, q(this.maxY, -b)), this.minX = Math.min(f, q(this.minX, b)), this.maxX = Math.max(k, q(this.maxX, -b)), e && void 0 === e.options.minRange && (e.minRange = Math.min(5 * w, (this.maxX - this.minX) / 5, e.minRange || b)), d && void 0 === d.options.minRange && (d.minRange = Math.min(5 * w, (this.maxY - this.minY) / 5, d.minRange || b)));\n      },\n      hasData: function hasData() {\n        return !!this.processedXData.length;\n      },\n      getExtremes: function getExtremes() {\n        b.prototype.getExtremes.call(this, this.valueData);\n        this.chart.hasRendered && this.isDirtyData && this.getBox(this.options.data);\n        this.valueMin = this.dataMin;\n        this.valueMax = this.dataMax;\n        this.dataMin = this.minY;\n        this.dataMax = this.maxY;\n      },\n      translatePath: function translatePath(a) {\n        var c = !1,\n            b = this.xAxis,\n            f = this.yAxis,\n            l = b.min,\n            n = b.transA,\n            b = b.minPixelPadding,\n            e = f.min,\n            d = f.transA,\n            f = f.minPixelPadding,\n            u,\n            h = [];\n        if (a) for (u = a.length; u--;) {\n          t(a[u]) ? (h[u] = c ? (a[u] - l) * n + b : (a[u] - e) * d + f, c = !c) : h[u] = a[u];\n        }\n        return h;\n      },\n      setData: function setData(c, f, k, e) {\n        var l = this.options,\n            n = this.chart.options.chart,\n            m = n && n.map,\n            d = l.mapData,\n            u = l.joinBy,\n            v = null === u,\n            h = l.keys || this.pointArrayMap,\n            g = [],\n            y = {},\n            q = this.chart.mapTransforms;\n        !d && m && (d = \"string\" === typeof m ? a.maps[m] : m);\n        v && (u = \"_i\");\n        u = this.joinBy = p(u);\n        u[1] || (u[1] = u[0]);\n        c && c.forEach(function (b, n) {\n          var k = 0;\n          if (t(b)) c[n] = {\n            value: b\n          };else if (x(b)) {\n            c[n] = {};\n            !l.keys && b.length > h.length && \"string\" === typeof b[0] && (c[n][\"hc-key\"] = b[0], ++k);\n\n            for (var m = 0; m < h.length; ++m, ++k) {\n              h[m] && void 0 !== b[k] && (0 < h[m].indexOf(\".\") ? a.Point.prototype.setNestedProperty(c[n], b[k], h[m]) : c[n][h[m]] = b[k]);\n            }\n          }\n          v && (c[n]._i = n);\n        });\n        this.getBox(c);\n        (this.chart.mapTransforms = q = n && n.mapTransforms || d && d[\"hc-transform\"] || q) && a.objectEach(q, function (a) {\n          a.rotation && (a.cosAngle = Math.cos(a.rotation), a.sinAngle = Math.sin(a.rotation));\n        });\n\n        if (d) {\n          \"FeatureCollection\" === d.type && (this.mapTitle = d.title, d = a.geojson(d, this.type, this));\n          this.mapData = d;\n          this.mapMap = {};\n\n          for (q = 0; q < d.length; q++) {\n            n = d[q], m = n.properties, n._i = q, u[0] && m && m[u[0]] && (n[u[0]] = m[u[0]]), y[n[u[0]]] = n;\n          }\n\n          this.mapMap = y;\n          c && u[1] && c.forEach(function (a) {\n            y[a[u[1]]] && g.push(y[a[u[1]]]);\n          });\n          l.allAreas ? (this.getBox(d), c = c || [], u[1] && c.forEach(function (a) {\n            g.push(a[u[1]]);\n          }), g = \"|\" + g.map(function (a) {\n            return a && a[u[0]];\n          }).join(\"|\") + \"|\", d.forEach(function (a) {\n            u[0] && -1 !== g.indexOf(\"|\" + a[u[0]] + \"|\") || (c.push(r(a, {\n              value: null\n            })), e = !1);\n          })) : this.getBox(g);\n        }\n\n        b.prototype.setData.call(this, c, f, k, e);\n      },\n      drawGraph: d,\n      drawDataLabels: d,\n      doFullTranslate: function doFullTranslate() {\n        return this.isDirtyData || this.chart.isResizing || this.chart.renderer.isVML || !this.baseTrans;\n      },\n      translate: function translate() {\n        var a = this,\n            b = a.xAxis,\n            k = a.yAxis,\n            f = a.doFullTranslate();\n        a.generatePoints();\n        a.data.forEach(function (c) {\n          c.plotX = b.toPixels(c._midX, !0);\n          c.plotY = k.toPixels(c._midY, !0);\n          f && (c.shapeType = \"path\", c.shapeArgs = {\n            d: a.translatePath(c.path)\n          });\n        });\n        a.translateColors();\n      },\n      pointAttribs: function pointAttribs(a, b) {\n        b = a.series.chart.styledMode ? this.colorAttribs(a) : y.column.prototype.pointAttribs.call(this, a, b);\n        b[\"stroke-width\"] = q(a.options[this.pointAttrToOptions && this.pointAttrToOptions[\"stroke-width\"] || \"borderWidth\"], \"inherit\");\n        return b;\n      },\n      drawPoints: function drawPoints() {\n        var a = this,\n            b = a.xAxis,\n            k = a.yAxis,\n            f = a.group,\n            l = a.chart,\n            n = l.renderer,\n            e,\n            d,\n            u,\n            h,\n            g = this.baseTrans,\n            p,\n            t,\n            r,\n            x,\n            F;\n        a.transformGroup || (a.transformGroup = n.g().attr({\n          scaleX: 1,\n          scaleY: 1\n        }).add(f), a.transformGroup.survive = !0);\n        a.doFullTranslate() ? (l.hasRendered && !l.styledMode && a.points.forEach(function (c) {\n          c.shapeArgs && (c.shapeArgs.fill = a.pointAttribs(c, c.state).fill);\n        }), a.group = a.transformGroup, y.column.prototype.drawPoints.apply(a), a.group = f, a.points.forEach(function (c) {\n          c.graphic && (c.name && c.graphic.addClass(\"highcharts-name-\" + c.name.replace(/ /g, \"-\").toLowerCase()), c.properties && c.properties[\"hc-key\"] && c.graphic.addClass(\"highcharts-key-\" + c.properties[\"hc-key\"].toLowerCase()), l.styledMode && c.graphic.css(a.pointAttribs(c, c.selected && \"select\")));\n        }), this.baseTrans = {\n          originX: b.min - b.minPixelPadding / b.transA,\n          originY: k.min - k.minPixelPadding / k.transA + (k.reversed ? 0 : k.len / k.transA),\n          transAX: b.transA,\n          transAY: k.transA\n        }, this.transformGroup.animate({\n          translateX: 0,\n          translateY: 0,\n          scaleX: 1,\n          scaleY: 1\n        })) : (e = b.transA / g.transAX, d = k.transA / g.transAY, u = b.toPixels(g.originX, !0), h = k.toPixels(g.originY, !0), .99 < e && 1.01 > e && .99 < d && 1.01 > d && (d = e = 1, u = Math.round(u), h = Math.round(h)), p = this.transformGroup, l.renderer.globalAnimation ? (t = p.attr(\"translateX\"), r = p.attr(\"translateY\"), x = p.attr(\"scaleX\"), F = p.attr(\"scaleY\"), p.attr({\n          animator: 0\n        }).animate({\n          animator: 1\n        }, {\n          step: function step(a, c) {\n            p.attr({\n              translateX: t + (u - t) * c.pos,\n              translateY: r + (h - r) * c.pos,\n              scaleX: x + (e - x) * c.pos,\n              scaleY: F + (d - F) * c.pos\n            });\n          }\n        })) : p.attr({\n          translateX: u,\n          translateY: h,\n          scaleX: e,\n          scaleY: d\n        }));\n        l.styledMode || f.element.setAttribute(\"stroke-width\", q(a.options[a.pointAttrToOptions && a.pointAttrToOptions[\"stroke-width\"] || \"borderWidth\"], 1) / (e || 1));\n        this.drawMapDataLabels();\n      },\n      drawMapDataLabels: function drawMapDataLabels() {\n        b.prototype.drawDataLabels.call(this);\n        this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect);\n      },\n      render: function render() {\n        var a = this,\n            f = b.prototype.render;\n        a.chart.renderer.isVML && 3E3 < a.data.length ? setTimeout(function () {\n          f.call(a);\n        }) : f.call(a);\n      },\n      animate: function animate(a) {\n        var c = this.options.animation,\n            b = this.group,\n            f = this.xAxis,\n            l = this.yAxis,\n            n = f.pos,\n            e = l.pos;\n        this.chart.renderer.isSVG && (!0 === c && (c = {\n          duration: 1E3\n        }), a ? b.attr({\n          translateX: n + f.len / 2,\n          translateY: e + l.len / 2,\n          scaleX: .001,\n          scaleY: .001\n        }) : (b.animate({\n          translateX: n,\n          translateY: e,\n          scaleX: 1,\n          scaleY: 1\n        }, c), this.animate = null));\n      },\n      animateDrilldown: function animateDrilldown(a) {\n        var c = this.chart.plotBox,\n            b = this.chart.drilldownLevels[this.chart.drilldownLevels.length - 1],\n            f = b.bBox,\n            l = this.chart.options.drilldown.animation;\n        a || (a = Math.min(f.width / c.width, f.height / c.height), b.shapeArgs = {\n          scaleX: a,\n          scaleY: a,\n          translateX: f.x,\n          translateY: f.y\n        }, this.points.forEach(function (a) {\n          a.graphic && a.graphic.attr(b.shapeArgs).animate({\n            scaleX: 1,\n            scaleY: 1,\n            translateX: 0,\n            translateY: 0\n          }, l);\n        }), this.animate = null);\n      },\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,\n      animateDrillupFrom: function animateDrillupFrom(a) {\n        y.column.prototype.animateDrillupFrom.call(this, a);\n      },\n      animateDrillupTo: function animateDrillupTo(a) {\n        y.column.prototype.animateDrillupTo.call(this, a);\n      }\n    }), h({\n      applyOptions: function applyOptions(a, b) {\n        a = e.prototype.applyOptions.call(this, a, b);\n        b = this.series;\n        var c = b.joinBy;\n        b.mapData && ((c = void 0 !== a[c[1]] && b.mapMap[a[c[1]]]) ? (b.xyFromShape && (a.x = c._midX, a.y = c._midY), h(a, c)) : a.value = a.value || null);\n        return a;\n      },\n      onMouseOver: function onMouseOver(c) {\n        a.clearTimeout(this.colorInterval);\n        if (null !== this.value || this.series.options.nullInteraction) e.prototype.onMouseOver.call(this, c);else this.series.onMouseOut(c);\n      },\n      zoomTo: function zoomTo() {\n        var a = this.series;\n        a.xAxis.setExtremes(this._minX, this._maxX, !1);\n        a.yAxis.setExtremes(this._minY, this._maxY, !1);\n        a.chart.redraw();\n      }\n    }, g));\n  });\n  z(g, \"parts-map/MapLineSeries.js\", [g[\"parts/Globals.js\"]], function (a) {\n    var g = a.seriesType,\n        h = a.seriesTypes;\n    g(\"mapline\", \"map\", {\n      lineWidth: 1,\n      fillColor: \"none\"\n    }, {\n      type: \"mapline\",\n      colorProp: \"stroke\",\n      pointAttrToOptions: {\n        stroke: \"color\",\n        \"stroke-width\": \"lineWidth\"\n      },\n      pointAttribs: function pointAttribs(a, g) {\n        a = h.map.prototype.pointAttribs.call(this, a, g);\n        a.fill = this.options.fillColor;\n        return a;\n      },\n      drawLegendSymbol: h.line.prototype.drawLegendSymbol\n    });\n  });\n  z(g, \"parts-map/MapPointSeries.js\", [g[\"parts/Globals.js\"]], function (a) {\n    var g = a.merge,\n        h = a.Point;\n    a = a.seriesType;\n    a(\"mappoint\", \"scatter\", {\n      dataLabels: {\n        crop: !1,\n        defer: !1,\n        enabled: !0,\n        formatter: function formatter() {\n          return this.point.name;\n        },\n        overflow: !1,\n        style: {\n          color: \"#000000\"\n        }\n      }\n    }, {\n      type: \"mappoint\",\n      forceDL: !0\n    }, {\n      applyOptions: function applyOptions(a, r) {\n        a = void 0 !== a.lat && void 0 !== a.lon ? g(a, this.series.chart.fromLatLonToPoint(a)) : a;\n        return h.prototype.applyOptions.call(this, a, r);\n      }\n    });\n  });\n  z(g, \"parts-more/BubbleLegend.js\", [g[\"parts/Globals.js\"]], function (a) {\n    var g = a.Series,\n        h = a.Legend,\n        t = a.Chart,\n        r = a.addEvent,\n        d = a.wrap,\n        q = a.color,\n        x = a.isNumber,\n        e = a.numberFormat,\n        b = a.objectEach,\n        f = a.merge,\n        y = a.noop,\n        p = a.pick,\n        c = a.stableSort,\n        m = a.setOptions,\n        k = a.arrayMin,\n        v = a.arrayMax;\n    m({\n      legend: {\n        bubbleLegend: {\n          borderColor: void 0,\n          borderWidth: 2,\n          className: void 0,\n          color: void 0,\n          connectorClassName: void 0,\n          connectorColor: void 0,\n          connectorDistance: 60,\n          connectorWidth: 1,\n          enabled: !1,\n          labels: {\n            className: void 0,\n            allowOverlap: !1,\n            format: \"\",\n            formatter: void 0,\n            align: \"right\",\n            style: {\n              fontSize: 10,\n              color: void 0\n            },\n            x: 0,\n            y: 0\n          },\n          maxSize: 60,\n          minSize: 10,\n          legendIndex: 0,\n          ranges: {\n            value: void 0,\n            borderColor: void 0,\n            color: void 0,\n            connectorColor: void 0\n          },\n          sizeBy: \"area\",\n          sizeByAbsoluteValue: !1,\n          zIndex: 1,\n          zThreshold: 0\n        }\n      }\n    });\n\n    a.BubbleLegend = function (a, c) {\n      this.init(a, c);\n    };\n\n    a.BubbleLegend.prototype = {\n      init: function init(a, c) {\n        this.options = a;\n        this.visible = !0;\n        this.chart = c.chart;\n        this.legend = c;\n      },\n      setState: y,\n      addToLegend: function addToLegend(a) {\n        a.splice(this.options.legendIndex, 0, this);\n      },\n      drawLegendSymbol: function drawLegendSymbol(a) {\n        var b = this.chart,\n            l = this.options,\n            f = p(a.options.itemDistance, 20),\n            e,\n            d = l.ranges;\n        e = l.connectorDistance;\n        this.fontMetrics = b.renderer.fontMetrics(l.labels.style.fontSize.toString() + \"px\");\n        d && d.length && x(d[0].value) ? (c(d, function (a, c) {\n          return c.value - a.value;\n        }), this.ranges = d, this.setOptions(), this.render(), b = this.getMaxLabelSize(), d = this.ranges[0].radius, a = 2 * d, e = e - d + b.width, e = 0 < e ? e : 0, this.maxLabel = b, this.movementX = \"left\" === l.labels.align ? e : 0, this.legendItemWidth = a + e + f, this.legendItemHeight = a + this.fontMetrics.h / 2) : a.options.bubbleLegend.autoRanges = !0;\n      },\n      setOptions: function setOptions() {\n        var a = this.ranges,\n            c = this.options,\n            b = this.chart.series[c.seriesIndex],\n            e = this.legend.baseline,\n            d = {\n          \"z-index\": c.zIndex,\n          \"stroke-width\": c.borderWidth\n        },\n            k = {\n          \"z-index\": c.zIndex,\n          \"stroke-width\": c.connectorWidth\n        },\n            m = this.getLabelStyles(),\n            g = b.options.marker.fillOpacity,\n            h = this.chart.styledMode;\n        a.forEach(function (l, n) {\n          h || (d.stroke = p(l.borderColor, c.borderColor, b.color), d.fill = p(l.color, c.color, 1 !== g ? q(b.color).setOpacity(g).get(\"rgba\") : b.color), k.stroke = p(l.connectorColor, c.connectorColor, b.color));\n          a[n].radius = this.getRangeRadius(l.value);\n          a[n] = f(a[n], {\n            center: a[0].radius - a[n].radius + e\n          });\n          h || f(!0, a[n], {\n            bubbleStyle: f(!1, d),\n            connectorStyle: f(!1, k),\n            labelStyle: m\n          });\n        }, this);\n      },\n      getLabelStyles: function getLabelStyles() {\n        var a = this.options,\n            c = {},\n            e = \"left\" === a.labels.align,\n            d = this.legend.options.rtl;\n        b(a.labels.style, function (a, b) {\n          \"color\" !== b && \"fontSize\" !== b && \"z-index\" !== b && (c[b] = a);\n        });\n        return f(!1, c, {\n          \"font-size\": a.labels.style.fontSize,\n          fill: p(a.labels.style.color, \"#000000\"),\n          \"z-index\": a.zIndex,\n          align: d || e ? \"right\" : \"left\"\n        });\n      },\n      getRangeRadius: function getRangeRadius(a) {\n        var c = this.options;\n        return this.chart.series[this.options.seriesIndex].getRadius.call(this, c.ranges[c.ranges.length - 1].value, c.ranges[0].value, c.minSize, c.maxSize, a);\n      },\n      render: function render() {\n        var a = this.chart.renderer,\n            c = this.options.zThreshold;\n        this.symbols || (this.symbols = {\n          connectors: [],\n          bubbleItems: [],\n          labels: []\n        });\n        this.legendSymbol = a.g(\"bubble-legend\");\n        this.legendItem = a.g(\"bubble-legend-item\");\n        this.legendSymbol.translateX = 0;\n        this.legendSymbol.translateY = 0;\n        this.ranges.forEach(function (a) {\n          a.value >= c && this.renderRange(a);\n        }, this);\n        this.legendSymbol.add(this.legendItem);\n        this.legendItem.add(this.legendGroup);\n        this.hideOverlappingLabels();\n      },\n      renderRange: function renderRange(a) {\n        var c = this.options,\n            b = c.labels,\n            l = this.chart.renderer,\n            f = this.symbols,\n            e = f.labels,\n            d = a.center,\n            k = Math.abs(a.radius),\n            m = c.connectorDistance,\n            g = b.align,\n            h = b.style.fontSize,\n            m = this.legend.options.rtl || \"left\" === g ? -m : m,\n            b = c.connectorWidth,\n            v = this.ranges[0].radius,\n            p = d - k - c.borderWidth / 2 + b / 2,\n            y,\n            h = h / 2 - (this.fontMetrics.h - h) / 2,\n            q = l.styledMode;\n        \"center\" === g && (m = 0, c.connectorDistance = 0, a.labelStyle.align = \"center\");\n        g = p + c.labels.y;\n        y = v + m + c.labels.x;\n        f.bubbleItems.push(l.circle(v, d + ((p % 1 ? 1 : .5) - (b % 2 ? 0 : .5)), k).attr(q ? {} : a.bubbleStyle).addClass((q ? \"highcharts-color-\" + this.options.seriesIndex + \" \" : \"\") + \"highcharts-bubble-legend-symbol \" + (c.className || \"\")).add(this.legendSymbol));\n        f.connectors.push(l.path(l.crispLine([\"M\", v, p, \"L\", v + m, p], c.connectorWidth)).attr(q ? {} : a.connectorStyle).addClass((q ? \"highcharts-color-\" + this.options.seriesIndex + \" \" : \"\") + \"highcharts-bubble-legend-connectors \" + (c.connectorClassName || \"\")).add(this.legendSymbol));\n        a = l.text(this.formatLabel(a), y, g + h).attr(q ? {} : a.labelStyle).addClass(\"highcharts-bubble-legend-labels \" + (c.labels.className || \"\")).add(this.legendSymbol);\n        e.push(a);\n        a.placed = !0;\n        a.alignAttr = {\n          x: y,\n          y: g + h\n        };\n      },\n      getMaxLabelSize: function getMaxLabelSize() {\n        var a, c;\n        this.symbols.labels.forEach(function (b) {\n          c = b.getBBox(!0);\n          a = a ? c.width > a.width ? c : a : c;\n        });\n        return a || {};\n      },\n      formatLabel: function formatLabel(c) {\n        var b = this.options,\n            f = b.labels.formatter;\n        return (b = b.labels.format) ? a.format(b, c) : f ? f.call(c) : e(c.value, 1);\n      },\n      hideOverlappingLabels: function hideOverlappingLabels() {\n        var a = this.chart,\n            c = this.symbols;\n        !this.options.labels.allowOverlap && c && (a.hideOverlappingLabels(c.labels), c.labels.forEach(function (a, b) {\n          a.newOpacity ? a.newOpacity !== a.oldOpacity && c.connectors[b].show() : c.connectors[b].hide();\n        }));\n      },\n      getRanges: function getRanges() {\n        var a = this.legend.bubbleLegend,\n            c,\n            b = a.options.ranges,\n            e,\n            d = Number.MAX_VALUE,\n            m = -Number.MAX_VALUE;\n        a.chart.series.forEach(function (a) {\n          a.isBubble && !a.ignoreSeries && (e = a.zData.filter(x), e.length && (d = p(a.options.zMin, Math.min(d, Math.max(k(e), !1 === a.options.displayNegative ? a.options.zThreshold : -Number.MAX_VALUE))), m = p(a.options.zMax, Math.max(m, v(e)))));\n        });\n        c = d === m ? [{\n          value: m\n        }] : [{\n          value: d\n        }, {\n          value: (d + m) / 2\n        }, {\n          value: m,\n          autoRanges: !0\n        }];\n        b.length && b[0].radius && c.reverse();\n        c.forEach(function (a, e) {\n          b && b[e] && (c[e] = f(!1, b[e], a));\n        });\n        return c;\n      },\n      predictBubbleSizes: function predictBubbleSizes() {\n        var a = this.chart,\n            c = this.fontMetrics,\n            b = a.legend.options,\n            e = \"horizontal\" === b.layout,\n            f = e ? a.legend.lastLineHeight : 0,\n            d = a.plotSizeX,\n            k = a.plotSizeY,\n            m = a.series[this.options.seriesIndex],\n            a = Math.ceil(m.minPxSize),\n            g = Math.ceil(m.maxPxSize),\n            m = m.options.maxSize,\n            h = Math.min(k, d);\n        if (b.floating || !/%$/.test(m)) c = g;else if (m = parseFloat(m), c = (h + f - c.h / 2) * m / 100 / (m / 100 + 1), e && k - c >= d || !e && d - c >= k) c = g;\n        return [a, Math.ceil(c)];\n      },\n      updateRanges: function updateRanges(a, c) {\n        var b = this.legend.options.bubbleLegend;\n        b.minSize = a;\n        b.maxSize = c;\n        b.ranges = this.getRanges();\n      },\n      correctSizes: function correctSizes() {\n        var a = this.legend,\n            c = this.chart.series[this.options.seriesIndex];\n        1 < Math.abs(Math.ceil(c.maxPxSize) - this.options.maxSize) && (this.updateRanges(this.options.minSize, c.maxPxSize), a.render());\n      }\n    };\n    r(a.Legend, \"afterGetAllItems\", function (c) {\n      var b = this.bubbleLegend,\n          e = this.options,\n          f = e.bubbleLegend,\n          d = this.chart.getVisibleBubbleSeriesIndex();\n      b && b.ranges && b.ranges.length && (f.ranges.length && (f.autoRanges = !!f.ranges[0].autoRanges), this.destroyItem(b));\n      0 <= d && e.enabled && f.enabled && (f.seriesIndex = d, this.bubbleLegend = new a.BubbleLegend(f, this), this.bubbleLegend.addToLegend(c.allItems));\n    });\n\n    t.prototype.getVisibleBubbleSeriesIndex = function () {\n      for (var a = this.series, c = 0; c < a.length;) {\n        if (a[c] && a[c].isBubble && a[c].visible && a[c].zData.length) return c;\n        c++;\n      }\n\n      return -1;\n    };\n\n    h.prototype.getLinesHeights = function () {\n      var a = this.allItems,\n          c = [],\n          b,\n          e = a.length,\n          f,\n          d = 0;\n\n      for (f = 0; f < e; f++) {\n        if (a[f].legendItemHeight && (a[f].itemHeight = a[f].legendItemHeight), a[f] === a[e - 1] || a[f + 1] && a[f]._legendItemPos[1] !== a[f + 1]._legendItemPos[1]) {\n          c.push({\n            height: 0\n          });\n          b = c[c.length - 1];\n\n          for (d; d <= f; d++) {\n            a[d].itemHeight > b.height && (b.height = a[d].itemHeight);\n          }\n\n          b.step = f;\n        }\n      }\n\n      return c;\n    };\n\n    h.prototype.retranslateItems = function (a) {\n      var c,\n          b,\n          f,\n          e = this.options.rtl,\n          d = 0;\n      this.allItems.forEach(function (k, m) {\n        c = k.legendGroup.translateX;\n        b = k._legendItemPos[1];\n        if ((f = k.movementX) || e && k.ranges) f = e ? c - k.options.maxSize / 2 : c + f, k.legendGroup.attr({\n          translateX: f\n        });\n        m > a[d].step && d++;\n        k.legendGroup.attr({\n          translateY: Math.round(b + a[d].height / 2)\n        });\n        k._legendItemPos[1] = b + a[d].height / 2;\n      });\n    };\n\n    r(g, \"legendItemClick\", function () {\n      var a = this.chart,\n          c = this.visible,\n          b = this.chart.legend;\n      b && b.bubbleLegend && (this.visible = !c, this.ignoreSeries = c, a = 0 <= a.getVisibleBubbleSeriesIndex(), b.bubbleLegend.visible !== a && (b.update({\n        bubbleLegend: {\n          enabled: a\n        }\n      }), b.bubbleLegend.visible = a), this.visible = c);\n    });\n    d(t.prototype, \"drawChartBox\", function (a, c, f) {\n      var e = this.legend,\n          d = 0 <= this.getVisibleBubbleSeriesIndex(),\n          k;\n      e && e.options.enabled && e.bubbleLegend && e.options.bubbleLegend.autoRanges && d ? (k = e.bubbleLegend.options, d = e.bubbleLegend.predictBubbleSizes(), e.bubbleLegend.updateRanges(d[0], d[1]), k.placed || (e.group.placed = !1, e.allItems.forEach(function (a) {\n        a.legendGroup.translateY = null;\n      })), e.render(), this.getMargins(), this.axes.forEach(function (a) {\n        a.render();\n        k.placed || (a.setScale(), a.updateNames(), b(a.ticks, function (a) {\n          a.isNew = !0;\n          a.isNewLabel = !0;\n        }));\n      }), k.placed = !0, this.getMargins(), a.call(this, c, f), e.bubbleLegend.correctSizes(), e.retranslateItems(e.getLinesHeights())) : (a.call(this, c, f), e && e.options.enabled && e.bubbleLegend && (e.render(), e.retranslateItems(e.getLinesHeights())));\n    });\n  });\n  z(g, \"parts-more/BubbleSeries.js\", [g[\"parts/Globals.js\"]], function (a) {\n    var g = a.arrayMax,\n        h = a.arrayMin,\n        t = a.Axis,\n        r = a.color,\n        d = a.isNumber,\n        q = a.noop,\n        x = a.pick,\n        e = a.pInt,\n        b = a.Point,\n        f = a.Series,\n        y = a.seriesType,\n        p = a.seriesTypes;\n    y(\"bubble\", \"scatter\", {\n      dataLabels: {\n        formatter: function formatter() {\n          return this.point.z;\n        },\n        inside: !0,\n        verticalAlign: \"middle\"\n      },\n      animationLimit: 250,\n      marker: {\n        lineColor: null,\n        lineWidth: 1,\n        fillOpacity: .5,\n        radius: null,\n        states: {\n          hover: {\n            radiusPlus: 0\n          }\n        },\n        symbol: \"circle\"\n      },\n      minSize: 8,\n      maxSize: \"20%\",\n      softThreshold: !1,\n      states: {\n        hover: {\n          halo: {\n            size: 5\n          }\n        }\n      },\n      tooltip: {\n        pointFormat: \"({point.x}, {point.y}), Size: {point.z}\"\n      },\n      turboThreshold: 0,\n      zThreshold: 0,\n      zoneAxis: \"z\"\n    }, {\n      pointArrayMap: [\"y\", \"z\"],\n      parallelArrays: [\"x\", \"y\", \"z\"],\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      specialGroup: \"group\",\n      bubblePadding: !0,\n      zoneAxis: \"z\",\n      directTouch: !0,\n      isBubble: !0,\n      pointAttribs: function pointAttribs(a, b) {\n        var c = this.options.marker.fillOpacity;\n        a = f.prototype.pointAttribs.call(this, a, b);\n        1 !== c && (a.fill = r(a.fill).setOpacity(c).get(\"rgba\"));\n        return a;\n      },\n      getRadii: function getRadii(a, b, e) {\n        var c,\n            f = this.zData,\n            d = e.minPxSize,\n            k = e.maxPxSize,\n            m = [],\n            g;\n        c = 0;\n\n        for (e = f.length; c < e; c++) {\n          g = f[c], m.push(this.getRadius(a, b, d, k, g));\n        }\n\n        this.radii = m;\n      },\n      getRadius: function getRadius(a, b, e, f, l) {\n        var c = this.options,\n            k = \"width\" !== c.sizeBy,\n            m = c.zThreshold,\n            g = b - a;\n        c.sizeByAbsoluteValue && null !== l && (l = Math.abs(l - m), g = Math.max(b - m, Math.abs(a - m)), a = 0);\n        d(l) ? l < a ? e = e / 2 - 1 : (a = 0 < g ? (l - a) / g : .5, k && 0 <= a && (a = Math.sqrt(a)), e = Math.ceil(e + a * (f - e)) / 2) : e = null;\n        return e;\n      },\n      animate: function animate(a) {\n        !a && this.points.length < this.options.animationLimit && (this.points.forEach(function (a) {\n          var c = a.graphic,\n              b;\n          c && c.width && (b = {\n            x: c.x,\n            y: c.y,\n            width: c.width,\n            height: c.height\n          }, c.attr({\n            x: a.plotX,\n            y: a.plotY,\n            width: 1,\n            height: 1\n          }), c.animate(b, this.options.animation));\n        }, this), this.animate = null);\n      },\n      hasData: function hasData() {\n        return !!this.processedXData.length;\n      },\n      translate: function translate() {\n        var c,\n            b = this.data,\n            e,\n            f,\n            l = this.radii;\n        p.scatter.prototype.translate.call(this);\n\n        for (c = b.length; c--;) {\n          e = b[c], f = l ? l[c] : 0, d(f) && f >= this.minPxSize / 2 ? (e.marker = a.extend(e.marker, {\n            radius: f,\n            width: 2 * f,\n            height: 2 * f\n          }), e.dlBox = {\n            x: e.plotX - f,\n            y: e.plotY - f,\n            width: 2 * f,\n            height: 2 * f\n          }) : e.shapeArgs = e.plotY = e.dlBox = void 0;\n        }\n      },\n      alignDataLabel: p.column.prototype.alignDataLabel,\n      buildKDTree: q,\n      applyZones: q\n    }, {\n      haloPath: function haloPath(a) {\n        return b.prototype.haloPath.call(this, 0 === a ? 0 : (this.marker ? this.marker.radius || 0 : 0) + a);\n      },\n      ttBelow: !1\n    });\n\n    t.prototype.beforePadding = function () {\n      var c = this,\n          b = this.len,\n          f = this.chart,\n          p = 0,\n          l = b,\n          n = this.isXAxis,\n          y = n ? \"xData\" : \"yData\",\n          q = this.min,\n          r = {},\n          t = Math.min(f.plotWidth, f.plotHeight),\n          z = Number.MAX_VALUE,\n          C = -Number.MAX_VALUE,\n          D = this.max - q,\n          B = b / D,\n          E = [];\n      this.series.forEach(function (b) {\n        var d = b.options;\n        !b.bubblePadding || !b.visible && f.options.chart.ignoreHiddenSeries || (c.allowZoomOutside = !0, E.push(b), n && ([\"minSize\", \"maxSize\"].forEach(function (a) {\n          var b = d[a],\n              c = /%$/.test(b),\n              b = e(b);\n          r[a] = c ? t * b / 100 : b;\n        }), b.minPxSize = r.minSize, b.maxPxSize = Math.max(r.maxSize, r.minSize), b = b.zData.filter(a.isNumber), b.length && (z = x(d.zMin, Math.min(z, Math.max(h(b), !1 === d.displayNegative ? d.zThreshold : -Number.MAX_VALUE))), C = x(d.zMax, Math.max(C, g(b))))));\n      });\n      E.forEach(function (a) {\n        var b = a[y],\n            e = b.length,\n            f;\n        n && a.getRadii(z, C, a);\n        if (0 < D) for (; e--;) {\n          d(b[e]) && c.dataMin <= b[e] && b[e] <= c.dataMax && (f = a.radii[e], p = Math.min((b[e] - q) * B - f, p), l = Math.max((b[e] - q) * B + f, l));\n        }\n      });\n      E.length && 0 < D && !this.isLog && (l -= b, B *= (b + Math.max(0, p) - Math.min(l, b)) / b, [[\"min\", \"userMin\", p], [\"max\", \"userMax\", l]].forEach(function (a) {\n        void 0 === x(c.options[a[0]], c[a[1]]) && (c[a[0]] += a[2] / B);\n      }));\n    };\n  });\n  z(g, \"parts-map/MapBubbleSeries.js\", [g[\"parts/Globals.js\"]], function (a) {\n    var g = a.merge,\n        h = a.Point,\n        t = a.seriesType,\n        r = a.seriesTypes;\n    r.bubble && t(\"mapbubble\", \"bubble\", {\n      animationLimit: 500,\n      tooltip: {\n        pointFormat: \"{point.name}: {point.z}\"\n      }\n    }, {\n      xyFromShape: !0,\n      type: \"mapbubble\",\n      pointArrayMap: [\"z\"],\n      getMapData: r.map.prototype.getMapData,\n      getBox: r.map.prototype.getBox,\n      setData: r.map.prototype.setData\n    }, {\n      applyOptions: function applyOptions(a, q) {\n        return a && void 0 !== a.lat && void 0 !== a.lon ? h.prototype.applyOptions.call(this, g(a, this.series.chart.fromLatLonToPoint(a)), q) : r.map.prototype.pointClass.prototype.applyOptions.call(this, a, q);\n      },\n      isValid: function isValid() {\n        return \"number\" === typeof this.z;\n      },\n      ttBelow: !1\n    });\n  });\n  z(g, \"parts-map/HeatmapSeries.js\", [g[\"parts/Globals.js\"]], function (a) {\n    var g = a.colorPointMixin,\n        h = a.merge,\n        t = a.noop,\n        r = a.pick,\n        d = a.Series,\n        q = a.seriesType,\n        x = a.seriesTypes;\n    q(\"heatmap\", \"scatter\", {\n      animation: !1,\n      borderWidth: 0,\n      nullColor: \"#f7f7f7\",\n      dataLabels: {\n        formatter: function formatter() {\n          return this.point.value;\n        },\n        inside: !0,\n        verticalAlign: \"middle\",\n        crop: !1,\n        overflow: !1,\n        padding: 0\n      },\n      marker: null,\n      pointRange: null,\n      tooltip: {\n        pointFormat: \"{point.x}, {point.y}: {point.value}\\x3cbr/\\x3e\"\n      },\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .2\n        }\n      }\n    }, h(a.colorSeriesMixin, {\n      pointArrayMap: [\"y\", \"value\"],\n      hasPointSpecificOptions: !0,\n      getExtremesFromAll: !0,\n      directTouch: !0,\n      init: function init() {\n        var a;\n        x.scatter.prototype.init.apply(this, arguments);\n        a = this.options;\n        a.pointRange = r(a.pointRange, a.colsize || 1);\n        this.yAxis.axisPointRange = a.rowsize || 1;\n      },\n      translate: function translate() {\n        var a = this.options,\n            b = this.xAxis,\n            f = this.yAxis,\n            d = a.pointPadding || 0,\n            g = function g(a, b, c) {\n          return Math.min(Math.max(b, a), c);\n        },\n            c = this.pointPlacementToXValue();\n\n        this.generatePoints();\n        this.points.forEach(function (e) {\n          var k = (a.colsize || 1) / 2,\n              m = (a.rowsize || 1) / 2,\n              l = g(Math.round(b.len - b.translate(e.x - k, 0, 1, 0, 1, -c)), -b.len, 2 * b.len),\n              k = g(Math.round(b.len - b.translate(e.x + k, 0, 1, 0, 1, -c)), -b.len, 2 * b.len),\n              h = g(Math.round(f.translate(e.y - m, 0, 1, 0, 1)), -f.len, 2 * f.len),\n              m = g(Math.round(f.translate(e.y + m, 0, 1, 0, 1)), -f.len, 2 * f.len),\n              p = r(e.pointPadding, d);\n          e.plotX = e.clientX = (l + k) / 2;\n          e.plotY = (h + m) / 2;\n          e.shapeType = \"rect\";\n          e.shapeArgs = {\n            x: Math.min(l, k) + p,\n            y: Math.min(h, m) + p,\n            width: Math.abs(k - l) - 2 * p,\n            height: Math.abs(m - h) - 2 * p\n          };\n        });\n        this.translateColors();\n      },\n      drawPoints: function drawPoints() {\n        var a = this.chart.styledMode ? \"css\" : \"attr\";\n        x.column.prototype.drawPoints.call(this);\n        this.points.forEach(function (b) {\n          b.graphic[a](this.colorAttribs(b));\n        }, this);\n      },\n      hasData: function hasData() {\n        return !!this.processedXData.length;\n      },\n      getValidPoints: function getValidPoints(a, b) {\n        return d.prototype.getValidPoints.call(this, a, b, !0);\n      },\n      animate: t,\n      getBox: t,\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,\n      alignDataLabel: x.column.prototype.alignDataLabel,\n      getExtremes: function getExtremes() {\n        d.prototype.getExtremes.call(this, this.valueData);\n        this.valueMin = this.dataMin;\n        this.valueMax = this.dataMax;\n        d.prototype.getExtremes.call(this);\n      }\n    }), a.extend({\n      haloPath: function haloPath(a) {\n        if (!a) return [];\n        var b = this.shapeArgs;\n        return [\"M\", b.x - a, b.y - a, \"L\", b.x - a, b.y + b.height + a, b.x + b.width + a, b.y + b.height + a, b.x + b.width + a, b.y - a, \"Z\"];\n      }\n    }, g));\n  });\n  z(g, \"parts-map/GeoJSON.js\", [g[\"parts/Globals.js\"]], function (a) {\n    function g(a, b) {\n      var f,\n          e,\n          d,\n          c = !1,\n          m = a.x,\n          k = a.y;\n      a = 0;\n\n      for (f = b.length - 1; a < b.length; f = a++) {\n        e = b[a][1] > k, d = b[f][1] > k, e !== d && m < (b[f][0] - b[a][0]) * (k - b[a][1]) / (b[f][1] - b[a][1]) + b[a][0] && (c = !c);\n      }\n\n      return c;\n    }\n\n    var h = a.Chart,\n        t = a.extend,\n        r = a.format,\n        d = a.merge,\n        q = a.win,\n        x = a.wrap;\n\n    h.prototype.transformFromLatLon = function (e, b) {\n      if (void 0 === q.proj4) return a.error(21, !1, this), {\n        x: 0,\n        y: null\n      };\n      e = q.proj4(b.crs, [e.lon, e.lat]);\n      var f = b.cosAngle || b.rotation && Math.cos(b.rotation),\n          d = b.sinAngle || b.rotation && Math.sin(b.rotation);\n      e = b.rotation ? [e[0] * f + e[1] * d, -e[0] * d + e[1] * f] : e;\n      return {\n        x: ((e[0] - (b.xoffset || 0)) * (b.scale || 1) + (b.xpan || 0)) * (b.jsonres || 1) + (b.jsonmarginX || 0),\n        y: (((b.yoffset || 0) - e[1]) * (b.scale || 1) + (b.ypan || 0)) * (b.jsonres || 1) - (b.jsonmarginY || 0)\n      };\n    };\n\n    h.prototype.transformToLatLon = function (e, b) {\n      if (void 0 === q.proj4) a.error(21, !1, this);else {\n        e = {\n          x: ((e.x - (b.jsonmarginX || 0)) / (b.jsonres || 1) - (b.xpan || 0)) / (b.scale || 1) + (b.xoffset || 0),\n          y: ((-e.y - (b.jsonmarginY || 0)) / (b.jsonres || 1) + (b.ypan || 0)) / (b.scale || 1) + (b.yoffset || 0)\n        };\n        var f = b.cosAngle || b.rotation && Math.cos(b.rotation),\n            d = b.sinAngle || b.rotation && Math.sin(b.rotation);\n        b = q.proj4(b.crs, \"WGS84\", b.rotation ? {\n          x: e.x * f + e.y * -d,\n          y: e.x * d + e.y * f\n        } : e);\n        return {\n          lat: b.y,\n          lon: b.x\n        };\n      }\n    };\n\n    h.prototype.fromPointToLatLon = function (e) {\n      var b = this.mapTransforms,\n          f;\n\n      if (b) {\n        for (f in b) {\n          if (b.hasOwnProperty(f) && b[f].hitZone && g({\n            x: e.x,\n            y: -e.y\n          }, b[f].hitZone.coordinates[0])) return this.transformToLatLon(e, b[f]);\n        }\n\n        return this.transformToLatLon(e, b[\"default\"]);\n      }\n\n      a.error(22, !1, this);\n    };\n\n    h.prototype.fromLatLonToPoint = function (e) {\n      var b = this.mapTransforms,\n          f,\n          d;\n      if (!b) return a.error(22, !1, this), {\n        x: 0,\n        y: null\n      };\n\n      for (f in b) {\n        if (b.hasOwnProperty(f) && b[f].hitZone && (d = this.transformFromLatLon(e, b[f]), g({\n          x: d.x,\n          y: -d.y\n        }, b[f].hitZone.coordinates[0]))) return d;\n      }\n\n      return this.transformFromLatLon(e, b[\"default\"]);\n    };\n\n    a.geojson = function (a, b, f) {\n      var e = [],\n          d = [],\n          c = function c(a) {\n        var b,\n            c = a.length;\n        d.push(\"M\");\n\n        for (b = 0; b < c; b++) {\n          1 === b && d.push(\"L\"), d.push(a[b][0], -a[b][1]);\n        }\n      };\n\n      b = b || \"map\";\n      a.features.forEach(function (a) {\n        var f = a.geometry,\n            g = f.type,\n            f = f.coordinates;\n        a = a.properties;\n        var m;\n        d = [];\n        \"map\" === b || \"mapbubble\" === b ? (\"Polygon\" === g ? (f.forEach(c), d.push(\"Z\")) : \"MultiPolygon\" === g && (f.forEach(function (a) {\n          a.forEach(c);\n        }), d.push(\"Z\")), d.length && (m = {\n          path: d\n        })) : \"mapline\" === b ? (\"LineString\" === g ? c(f) : \"MultiLineString\" === g && f.forEach(c), d.length && (m = {\n          path: d\n        })) : \"mappoint\" === b && \"Point\" === g && (m = {\n          x: f[0],\n          y: -f[1]\n        });\n        m && e.push(t(m, {\n          name: a.name || a.NAME,\n          properties: a\n        }));\n      });\n      f && a.copyrightShort && (f.chart.mapCredits = r(f.chart.options.credits.mapText, {\n        geojson: a\n      }), f.chart.mapCreditsFull = r(f.chart.options.credits.mapTextFull, {\n        geojson: a\n      }));\n      return e;\n    };\n\n    x(h.prototype, \"addCredits\", function (a, b) {\n      b = d(!0, this.options.credits, b);\n      this.mapCredits && (b.href = null);\n      a.call(this, b);\n      this.credits && this.mapCreditsFull && this.credits.attr({\n        title: this.mapCreditsFull\n      });\n    });\n  });\n  z(g, \"parts-map/Map.js\", [g[\"parts/Globals.js\"]], function (a) {\n    function g(a, b, d, c, e, g, h, l) {\n      return [\"M\", a + e, b, \"L\", a + d - g, b, \"C\", a + d - g / 2, b, a + d, b + g / 2, a + d, b + g, \"L\", a + d, b + c - h, \"C\", a + d, b + c - h / 2, a + d - h / 2, b + c, a + d - h, b + c, \"L\", a + l, b + c, \"C\", a + l / 2, b + c, a, b + c - l / 2, a, b + c - l, \"L\", a, b + e, \"C\", a, b + e / 2, a + e / 2, b, a + e, b, \"Z\"];\n    }\n\n    var h = a.Chart,\n        t = a.defaultOptions,\n        r = a.extend,\n        d = a.merge,\n        q = a.pick,\n        x = a.Renderer,\n        e = a.SVGRenderer,\n        b = a.VMLRenderer;\n    r(t.lang, {\n      zoomIn: \"Zoom in\",\n      zoomOut: \"Zoom out\"\n    });\n    t.mapNavigation = {\n      buttonOptions: {\n        alignTo: \"plotBox\",\n        align: \"left\",\n        verticalAlign: \"top\",\n        x: 0,\n        width: 18,\n        height: 18,\n        padding: 5,\n        style: {\n          fontSize: \"15px\",\n          fontWeight: \"bold\"\n        },\n        theme: {\n          \"stroke-width\": 1,\n          \"text-align\": \"center\"\n        }\n      },\n      buttons: {\n        zoomIn: {\n          onclick: function onclick() {\n            this.mapZoom(.5);\n          },\n          text: \"+\",\n          y: 0\n        },\n        zoomOut: {\n          onclick: function onclick() {\n            this.mapZoom(2);\n          },\n          text: \"-\",\n          y: 28\n        }\n      },\n      mouseWheelSensitivity: 1.1\n    };\n\n    a.splitPath = function (a) {\n      var b;\n      a = a.replace(/([A-Za-z])/g, \" $1 \");\n      a = a.replace(/^\\s*/, \"\").replace(/\\s*$/, \"\");\n      a = a.split(/[ ,]+/);\n\n      for (b = 0; b < a.length; b++) {\n        /[a-zA-Z]/.test(a[b]) || (a[b] = parseFloat(a[b]));\n      }\n\n      return a;\n    };\n\n    a.maps = {};\n\n    e.prototype.symbols.topbutton = function (a, b, d, c, e) {\n      return g(a - 1, b - 1, d, c, e.r, e.r, 0, 0);\n    };\n\n    e.prototype.symbols.bottombutton = function (a, b, d, c, e) {\n      return g(a - 1, b - 1, d, c, 0, 0, e.r, e.r);\n    };\n\n    x === b && [\"topbutton\", \"bottombutton\"].forEach(function (a) {\n      b.prototype.symbols[a] = e.prototype.symbols[a];\n    });\n\n    a.Map = a.mapChart = function (b, e, g) {\n      var c = \"string\" === typeof b || b.nodeName,\n          f = arguments[c ? 1 : 0],\n          k = f,\n          p = {\n        endOnTick: !1,\n        visible: !1,\n        minPadding: 0,\n        maxPadding: 0,\n        startOnTick: !1\n      },\n          l,\n          n = a.getOptions().credits;\n      l = f.series;\n      f.series = null;\n      f = d({\n        chart: {\n          panning: \"xy\",\n          type: \"map\"\n        },\n        credits: {\n          mapText: q(n.mapText, \" \\xA9 <a href=\\\"{geojson.copyrightUrl}\\\">{geojson.copyrightShort}</a>\"),\n          mapTextFull: q(n.mapTextFull, \"{geojson.copyright}\")\n        },\n        tooltip: {\n          followTouchMove: !1\n        },\n        xAxis: p,\n        yAxis: d(p, {\n          reversed: !0\n        })\n      }, f, {\n        chart: {\n          inverted: !1,\n          alignTicks: !1\n        }\n      });\n      f.series = k.series = l;\n      return c ? new h(b, f, g) : new h(f, e);\n    };\n  });\n  z(g, \"masters/modules/map.src.js\", [], function () {});\n});","map":null,"metadata":{},"sourceType":"script"}